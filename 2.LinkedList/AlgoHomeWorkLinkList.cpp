/**
2.算法设计题
（1）将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其他的存储空间。表中不允许有重复的数据。
（2）将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其他的存储空间。表中允许有重复的数据。
（3）已知两个链表A和B分别表示两个集合，其元素递增排列。请设计一个算法，用于求出A与B的交集，并将结果存放在A链表中。
（4）已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出两个集合A和B的差集（仅由在A中出现而不在B中出现的元素所构成的集合），并将结果以同样的形式存储，同时返回该集合的元素个数。
（5）设计算法将一个带头节点的单链表A分解为两个具有相同结构的链表B和C，其中B表的节点为A表中值小于0的节点，而C表的节点为A表中值大于0的节点（链表A中的元素为非零整数，要求B、C表利用A表的节点）。
（6）设计一个算法，通过一趟遍历确定长度为n的单链表中值最大的节点。
（7）设计一个算法，将链表中所有节点的链接方向“原地”逆转，即要求仅利用原表的存储空间，换句话说，要求算法的空间复杂度为O(1)。
（8）设计一个算法，删除递增有序链表中值大于mink且小于maxk的所有元素（mink和maxk是给定的两个参数，其值可以和表中的元素相同，也可以不同）。
（9）已知p指向双向循环链表中的一个节点，其节点结构为data、prior、next这3个域，设计算法change(p)，交换p所指向的节点及其前驱节点的顺序。
（10）已知长度为n的线性表A采用顺序存储结构，请设计一个时间复杂度为O（n)、空间复杂度为O（1）的算法，该算法可删除线性表中所有值为item的数据元素。
*/
#include <iostream>
#include "NodeList.hpp"

int main()
{
    return 0;
}